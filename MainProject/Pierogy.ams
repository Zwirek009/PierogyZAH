## ams_version=1.0

Model Main_Pierogy {
    Set Fabryki {
        Index: f;
    }
    Set Sklepy {
        Index: s;
    }
    Set Rodzaje_pierogow {
        Index: r;
    }
    Set Dni_pracy {
        Index: d;
    }
    Set Wiek_pierogow {
        Index: i;
    }
    Parameter Cena {
        IndexDomain: (r,s);
    }
    Parameter Zapotrzebowanie {
        IndexDomain: (d,r,s);
    }
    Parameter Koszt_produkcji {
        IndexDomain: (f,r);
    }
    Parameter Globalny_koszt_produkcji {
        IndexDomain: r;
    }
    Parameter Maksymalna_produkcja {
        IndexDomain: (f,r);
    }
    Parameter Koszt_transportu_1do1 {
        IndexDomain: s;
    }
    Parameter Pojemnosc_magazynu {
        IndexDomain: s;
    }
    Parameter Min_zamowienie;
    Parameter Max_zamowienie;
    Variable a {
        IndexDomain: (d,r,s);
        Range: integer;
        Comment: "Ilosc sprzedanych w dniu d pierogow rodzaju r w sklepie s";
    }
    Variable y {
        IndexDomain: (s,d,r,i);
        Range: integer;
        Comment: "Ilość pierogów rodzaju r leżących i-dni z punktu widzenia dnia d w magazynie sklepu s";
    }
    Variable w {
        IndexDomain: (s,d,r);
        Range: integer;
        Comment: "Ilość zmarnowanych pierogów rodzaju r w dniu d w sklepie s";
    }
    Variable z {
        IndexDomain: (s,d,r,i);
        Range: integer;
        Comment: "Ilość sprzedanych pierogów rodzaju r leżących już i-dni z punktu widzenia dnia d w magazynie sklepu s";
    }
    Variable mala_delta {
        IndexDomain: (d,s);
        Range: binary;
    }
    Constraint Ogr_na_popyt {
        IndexDomain: (d,r,s);
        Definition: a(d,r,s)<=Zapotrzebowanie(d,r,s);
        Comment: "Nie można sprzedać więcej niż jest popyt.";
    }
    Constraint Ogr_na_produkcje {
        IndexDomain: (d,f,r);
        Definition: sum[s, x(d,f,r,s)]<=Maksymalna_produkcja(f,r);
        Comment: "Nie można wyprodukować dziennie w fabryce f więcej niż Mfr pierogów.";
    }
    Constraint Ogr_na_sume_sprzedanych {
        IndexDomain: (d,r,s);
        Definition: a(d,r,s)=sum[f, x(d,f,r,s)];
        Comment: "Suma sprzedanych pierogów w sklepie s jest równa liczbie wyprodukowanych pierogów dla tego sklepu przez wszystkie fabryki w ciągu tego samego dnia.";
    }
    Constraint Pozostale_na_nastepny_dzien {
        IndexDomain: (s,r,d,i);
        Definition: y(s,d+1,r,i+1)=y(s,d,r,i)-z(s,d,r,i);
        Comment: "Na następny dzień zostaje w magazynie różnica pomiędzy ilością przechowywanych a ilością sprzedanych w dniu poprzednim.";
    }
    Constraint Maksimum_sprzedanych_dziennie {
        IndexDomain: (s,d,r);
        Definition: sum[i, z(s,d,r,i)]<=Zapotrzebowanie(d,r,s);
        Comment: "Każdego dnia d można maksymalnie sprzedać Zsdr pierogów rodzaju r w sklepie s.";
    }
    Constraint Zmarnowane_pierogi {
        IndexDomain: (s,d,r);
        Definition: w(s,d,r)=y(s,d,r,last(wiek_pierogow))-z(s,d,r,last(wiek_pierogow));
        Comment: "Ilość zmarnowanych pierogów w dniu d to ilość niewykorzystanych starych pierogów.";
    }
    Constraint Sprzedaz_a_stan_magazynu {
        IndexDomain: (s,d,r,i);
        Definition: z(s,d,r,i)<=y(s,d,r,i);
        Comment: "Nie można sprzedać więcej pierogów leżących i-dni niż jest ich w magazynie.";
    }
    Constraint Dodatniosc_magazynu {
        IndexDomain: (s,d,r,i);
        Definition: y(s,d,r,i)>=0;
        Comment: "W magazynie nie może znajdować się ujemna liczba leżących i-dni pierogów.";
    }
    Constraint Min_zamowionych {
        IndexDomain: (s,d);
        Definition: sum[r, y(s,d,r,first(Wiek_pierogow))]>=mala_delta(d,s)*Min_zamowienie;
        Comment: "Każdego dnia można zamówić zero lub co najmniej MINpierogów.";
    }
    Constraint Max_zamowionych {
        IndexDomain: (s,d);
        Definition: sum[r, y(s,d,r,first(Wiek_pierogow))]<=mala_delta(d,s)*Max_zamowienie;
        Comment: "Każdego dnia nie można zamówić więcej niż MAX pierogów.";
    }
    Constraint Brak_pracy_fabryki_w_niedziele {
        IndexDomain: (r,s);
        Definition: y(s,last(Dni_pracy),r,first(Wiek_pierogow))=0;
        Comment: "W niedzielę fabryka nie pracuje.";
    }
    Constraint Max_pojemnosc_magazynu {
        IndexDomain: (s,d,r);
        Definition: sum[i, y(s,d,r,i)]<=Pojemnosc_magazynu(s);
        Comment: "W magazynie każdego dnia nie może być przechowywane więcej niż CAP pierogów.";
    }
    Variable x {
        IndexDomain: (d,f,r,s);
        Range: integer;
        Comment: "Ilosc wyprodukowanych w dniu d w fabryce f pierogow rodzaju r dla sklepu s";
    }
    Variable Zysk_podst_1 {
        Range: free;
        Definition: sum[s, sum[r, sum[d, Cena(r,s)*a(d,r,s)]]]-sum[r, sum[s, sum[f, sum[d, Koszt_produkcji(f,r)*x(d,f,r,s)]]]];
        Comment: "Łączny zysk = łączny przychód - łączny koszt (ew sum[(s,r,d), formula])";
    }
    Variable Zysk_rozsz_1 {
        Range: free;
        Definition: sum[s, sum[d, sum[r, Cena(r,s)*sum[i, z(s,d,r,i)]-Globalny_koszt_produkcji(r)*(y(s,d,r,first(Wiek_pierogow))+w(s,d,r))]-Koszt_transportu_1do1(s)*mala_delta(d,s)]];
    }
    MathematicalProgram Maksymalizacja_zysku_podst_1 {
        Objective: Zysk_podst_1;
        Direction: maximize;
        Constraints: AllConstraints;
        Variables: AllVariables;
        Type: MIP;
    }
    MathematicalProgram Maksymalizacja_zysku_rozszerz_1 {
        Objective: Zysk_rozsz_1;
        Direction: maximize;
        Constraints: AllConstraints;
        Variables: AllVariables;
        Type: MIP;
    }
    Procedure MainInitialization {
        Comment: "Add initialization statements here that do NOT require any library being initialized already.";
    }
    Procedure PostMainInitialization {
        Comment: {
            "Add initialization statements here that require that the libraries are already initialized properly,
            or add statements that require the Data Management module to be initialized."
        }
    }
    Procedure MainExecution {
        Body: {
            solve Maksymalizacja_zysku_podst_1;
            solve Maksymalizacja_zysku_rozszerz_1;
        }
    }
    Procedure PreMainTermination {
        Body: {
            return DataManagementExit();
        }
        Comment: {
            "Add termination statements here that require all libraries to be still alive.
            Return 1 if you allow the termination sequence to continue.
            Return 0 if you want to cancel the termination sequence."
        }
    }
    Procedure MainTermination {
        Body: {
            return 1;
        }
        Comment: {
            "Add termination statements here that do not require all libraries to be still alive.
            Return 1 to allow the termination sequence to continue.
            Return 0 if you want to cancel the termination sequence.
            It is recommended to only use the procedure PreMainTermination to cancel the termination sequence and let this procedure always return 1."
        }
    }
}
